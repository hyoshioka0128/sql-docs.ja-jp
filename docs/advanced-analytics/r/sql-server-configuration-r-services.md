---
title: SQL Server の構成 (R Services)
ms.prod: sql
ms.technology: machine-learning
ms.date: 03/29/2019
ms.topic: conceptual
author: dphansen
ms.author: davidph
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: dda5d84aca714530bbc2bef79344db889e113d4f
ms.sourcegitcommit: 321497065ecd7ecde9bff378464db8da426e9e14
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/01/2019
ms.locfileid: "68714993"
---
# <a name="sql-server-configuration-for-use-with-r"></a>R で使用するための SQL Server 構成
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

この記事は、2つのケーススタディに基づく R Services のパフォーマンスの最適化について説明するシリーズの2番目の記事です。  この記事では、SQL Server R Services を実行するために使用されるコンピューターのハードウェアおよびネットワーク構成に関するガイダンスを提供します。 また、ソリューションで使用される SQL Server インスタンス、データベース、またはテーブルを構成する方法についても説明します。 SQL Server で NUMA を使用すると、ハードウェアとデータベースの最適化の間に線がぼかします。3番目のセクションでは、CPU affinitization とリソースガバナンスの詳細について説明します。

> [!TIP]
> SQL Server を初めて使用する場合は、「SQL Server パフォーマンスチューニングガイド」も確認することを強くお勧めします。[パフォーマンスを監視して調整](https://docs.microsoft.com/sql/relational-databases/performance/monitor-and-tune-for-performance)します。

## <a name="hardware-optimization"></a>ハードウェアの最適化

外部スクリプトを実行するためのリソースがあることを確認するには、サーバーコンピューターの最適化が重要です。 リソースが制限されている場合は、次のような現象が発生する可能性があります。

- 他のデータベース操作の優先順位を設定するために、ジョブの実行が延期または取り消されました
- "クォータを超過しました" というエラーが発生したため、R スクリプトは完了せずに終了します
- 不完全な結果を得るために、R メモリに読み込まれたデータが切り捨てられました

### <a name="memory"></a>Memory

コンピューター上で利用できるメモリの量は、高度な分析アルゴリズムのパフォーマンスに大きな影響を与える場合があります。 SQL コンピューティングコンテキストを使用する場合、メモリ不足によって並列処理の次数が影響を受ける可能性があります。 また、処理可能なチャンク サイズ (読み取り操作あたりの行数) や、サポートできる同時セッション数にも影響する可能性があります。

少なくとも 32 GB をお勧めします。 使用可能な容量が 32 GB を超える場合は、パフォーマンスを向上させるために、すべての読み取り操作でより多くの行を使用するように SQL データソースを構成できます。

また、インスタンスによって使用されるメモリを管理することもできます。 既定では、メモリが割り当てられている場合、SQL Server は外部スクリプトプロセスより優先されます。 R Services の既定のインストールでは、使用可能なメモリの 20% のみが R に割り当てられます。

通常、これはデータサイエンスタスクには不十分ですが、SQL server のメモリを使用しないようにする必要があります。 データベースエンジン、関連するサービス、外部スクリプトとの間のメモリ割り当てを実験して微調整する必要があります。また、大文字と小文字の違いによって、最適な構成が異なることを理解してください。

再開照合モデルの場合、外部スクリプトの使用は非常に高く、他のデータベースエンジンサービスは実行されていませんでした。したがって、外部スクリプトに割り当てられたリソースは 70% に増加しました。これは、スクリプトのパフォーマンスに最適な構成です。

### <a name="power-options"></a>電源オプション

Windows オペレーティングシステムでは、**高パフォーマンス**の電源オプションを使用する必要があります。 異なる電源設定を使用すると、SQL Server を使用した場合のパフォーマンスが低下または整合しなくなります。

### <a name="disk-io"></a>ディスク IO

R Services を使用したトレーニングジョブと予測ジョブは、本質的に IO にバインドされており、データベースが格納されているディスクの速度に依存します。 ソリッドステートドライブ (SSD) などの高速ドライブが役に立ちます。

ディスク IO は、ディスクにアクセスする他のアプリケーションによっても影響を受けます (たとえば、データベースに対して読み取り操作を行う他のクライアントなど)。 またディスク IO のパフォーマンスは、使用されているファイル システムの設定によっても影響を受けることがあります (ファイル システムによって使用されるブロック サイズなど)。

複数のドライブが使用可能な場合は、データベースエンジンの要求がデータベースに格納されているデータの要求と同じディスクに到達しないように、SQL Server とは異なるドライブにデータベースを格納します。

トレーニング時に RevoScaleR 分析関数を繰り返し実行する場合も、ディスク IO がパフォーマンスに大きな影響を与える可能性があります。 たとえば、、 `rxLogit`、 `rxDTree` `rxDForest`、および`rxBTrees`では、すべて複数の反復が使用されます。 データソースが SQL Server 場合、これらのアルゴリズムは、データをキャプチャするために最適化された一時ファイルを使用します。 これらのファイルは、セッションの完了後に自動的にクリーンアップされます。 読み取り/書き込み操作用に高パフォーマンスのディスクを使用すると、これらのアルゴリズムの全体的な経過時間を大幅に向上させることができます。

> [!NOTE]
> R Services の初期バージョンでは、Windows オペレーティングシステムでのファイル名のサポートが8.3 必要でした。 この制限は、Service Pack 1 の後で解除されました。 ただし、fsutil を使用して、ドライブで8.3 のファイル名がサポートされているかどうかを判断したり、サポートされていない場合にサポートを有効にしたりすることができます。

### <a name="paging-file"></a>ページング ファイル

Windows オペレーティング システムでは、クラッシュ ダンプの管理や仮想メモリ ページの格納に、ページング ファイルが使用されます。 過度なページングに気付いた場合は、コンピューター上の物理メモリを増やすことを検討してください。 物理メモリを増やしてもページングがなくなるわけではありませんが、ページングの必要性が減ります。

ページ ファイルが格納されるディスクの速度も、パフォーマンスに影響する可能性があります。 ページ ファイルを SSD に格納したり、複数の SSD 間で複数のページ ファイルを使用すると、パフォーマンスを改善できる可能性があります。

ページファイルのサイズを設定する方法については、「 [64 ビットバージョンの Windows で適切なページファイルのサイズを確認する方法](https://support.microsoft.com/kb/2860880)」を参照してください。

## <a name="optimizations-at-instance-or-database-level"></a>インスタンスレベルまたはデータベースレベルでの最適化

SQL Server インスタンスの最適化は、外部スクリプトを効率的に実行するための鍵です。

> [!NOTE]
> 最適な設定は、データのサイズと種類、モデルのスコア付けやトレーニングに使用している列の数によって異なります。
> 
> 最後の記事では、特定の最適化の結果を確認できます。[パフォーマンスチューニング-ケーススタディの結果](../../advanced-analytics/r/performance-case-study-r-services.md)
> 
> サンプルスクリプトについては、独立した[GitHub リポジトリ](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning)を参照してください。

### <a name="table-compression"></a>テーブル圧縮

多くの場合、IO パフォーマンスを向上させるには、圧縮または単票形式のデータストアを使用します。 一般に、データはテーブル内の複数の列で繰り返されることが多いため、列ストアを使用すると、データを圧縮するときにこれらの繰り返しを利用できます。

テーブルへの挿入が多数ある場合、列ストアは効率的ではない可能性がありますが、データが静的であるか、または変更頻度が低い場合は、この方法を選択することをお勧めします。 列ストアが適切でない場合は、行メジャー テーブルでの圧縮を有効にすることで、IO を改善できる可能性があります。

詳しくは、次の各ドキュメントをご覧ください。

+ [データの圧縮](../../relational-databases/data-compression/data-compression.md)

+ [テーブルまたはインデックスの圧縮を有効にする](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [列ストア インデックス ガイド](../../relational-databases/indexes/columnstore-indexes-overview.md)

### <a name="memory-optimized-tables"></a>メモリ最適化テーブル

最近のコンピューターでは、メモリが問題になりました。 ハードウェアの仕様が改善し続けるにつれて、RAM を良好な値で取得するのは比較的簡単です。 ただし、同時に、データはそれまでよりも早く生成され、データは短い待機時間で処理する必要があります。

メモリ最適化テーブルは、高度なコンピューターで使用可能な大容量のメモリを利用してビッグデータの問題を解決するという点で、1つのソリューションを表します。 メモリ最適化テーブルは主にメモリ内に存在するので、データはメモリに読み込まれ、メモリに書き込まれます。 持続性を確保するために、テーブルの2番目のコピーはディスク上に保持され、データはデータベースの復旧中にディスクからのみ読み取られます。

テーブルの読み取りと書き込みを頻繁に行う必要がある場合は、メモリ最適化テーブルを使用して、高いスケーラビリティと短い待機時間を実現できます。  再開照合シナリオでは、メモリ最適化テーブルを使用することで、データベースからすべての再開機能を読み取り、新しいジョブの開始と一致するようにメインメモリに格納することができました。 これにより、ディスク IO が大幅に減少しました。

複数の同時実行バッチからデータベースに予測を書き戻すプロセスで、メモリ最適化テーブルを使用すると、パフォーマンスがさらに向上しました。 SQL Server にメモリ最適化テーブルを使用すると、テーブルの読み取りと書き込みの待機時間が短くなります。

開発中のエクスペリエンスもシームレスでした。 持続性のあるメモリ最適化テーブルは、データベースの作成時と同時に作成されました。 そのため、開発では、データの格納場所に関係なく同じワークフローが使用されていました。

### <a name="processor"></a>プロセッサ

SQL Server は、コンピューターで使用可能なコアを使用して、タスクを並行して実行できます。使用可能なコア数が多いほど、パフォーマンスが向上します。 コアの数を増やすと IO バインド操作には役に立ちませんが、CPU バインドアルゴリズムでは、多くのコアを使用するより高速な cpu を利用できます。

サーバーは通常、複数のユーザーによって同時に使用されるため、データベース管理者は、ピーク時のワークロード計算をサポートするために必要なコアの数を決定する必要があります。

### <a name="resource-governance"></a>リソースガバナンス

Resource Governor をサポートするエディションでは、リソースプールを使用して、特定のワークロードにいくつかの Cpu が割り当てられるように指定できます。 また、特定のワークロードに割り当てられたメモリの量を管理することもできます。

SQL Server のリソースガバナンスにより、SQL Server および R によって使用されるさまざまなリソースの監視と制御を一元化できます。たとえば、データベースエンジンに使用可能なメモリの半分を割り当てて、一時的に重いワークロードでもコアサービスを常に実行できるようにすることができます。

外部スクリプトによるメモリ消費の既定値は、SQL Server 自体に使用できる合計メモリの 20% に制限されます。 この制限は、データベースサーバーに依存するすべてのタスクが長時間実行されている R ジョブによって重大な影響を受けないようにするために、既定で適用されます。 ただし、これらの制限はデータベース管理者によって変更することもできます。 多くの場合、重大な機械学習ワークロードをサポートするには 20% の制限は十分ではありません。

サポートされる構成オプションは、 **MAX_CPU_PERCENT**、 **MAX_MEMORY_PERCENT**、および**MAX_PROCESSES**です。 現在の設定を表示するには、次のステートメントを使用します。`SELECT * FROM sys.resource_governor_external_resource_pools`

-  サーバーが主に R Services で使用されている場合は、MAX_CPU_PERCENT を 40% または 60% に増やすと役立つことがあります。

-  多くの R セッションで同時に同じサーバーを使用する必要がある場合は、3つの設定をすべて増やす必要があります。

割り当てられたリソースの値を変更するには、T-sql ステートメントを使用します。

+ このステートメントでは、メモリ使用量を 40% に設定します。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_MEMORY_PERCENT = 40)`

+ このステートメントは、3つの構成可能な値をすべて設定します。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_CPU_PERCENT = 40, MAX_MEMORY_PERCENT = 50, MAX_PROCESSES = 20)`

+ メモリ、CPU、または最大のプロセス設定を変更し、すぐに設定を適用する場合は、次のステートメントを実行します。`ALTER RESOURCE GOVERNOR RECONFIGURE`

## <a name="soft-numa-hardware-numa-and-cpu-affinity"></a>ソフト NUMA、ハードウェア NUMA、および CPU アフィニティ

SQL Server を計算コンテキストとして使用する場合、NUMA とプロセッサのアフィニティに関連する設定をチューニングすることで、パフォーマンスを向上させることができます。 

_ハードウェア NUMA_を搭載したシステムには、それぞれが少数のプロセッサを提供する複数のシステムバスがあります。 各 CPU は、一貫した方法で、他のグループに関連付けられているメモリにアクセスできます。 この CPU の各グループのことを NUMA ノードと呼びます。 ハードウェア NUMA を使用する場合は、NUMA ではなくインターリーブされたメモリを使用するように構成できます。 その場合、Windows と SQL Server は NUMA として認識されません。 

次のクエリを実行すると、SQL Server に使用できるメモリノードの数を調べることができます。

```sql
SELECT DISTINCT memory_node_id
FROM sys.dm_os_memory_clerks
```

クエリが単一のメモリノード (ノード 0) を返す場合は、ハードウェア NUMA がないか、ハードウェアがインターリーブ (NUMA 以外) として構成されています。 また、cpu が4個以下の場合や、少なくとも1つのノードに CPU が1つしかない場合は、ハードウェア NUMA も無視されます。 SQL Server

コンピューターに複数のプロセッサが搭載されていても、ハードウェア NUMA が搭載されていない場合は、[ソフト numa](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)を使用して cpu をより小さなグループに分割することもできます。  SQL Server 2016 と SQL Server 2017 の両方で、SQL Server サービスを開始すると、ソフト NUMA 機能が自動的に有効になります。

ソフト NUMA が有効になっていると、SQL Server によってノードが自動的に管理されます。ただし、特定のワークロードを最適化するために、_ソフトアフィニティ_を無効にし、ソフト NUMA ノードの CPU 関係を手動で構成することができます。 これにより、特にリソースガバナンスをサポートする SQL Server のエディションを使用している場合に、どのワークロードがどのノードに割り当てられるかをより詳細に制御できるようになります。 CPU アフィニティを指定し、リソースプールを Cpu のグループに合わせることで、待機時間を短縮し、関連するプロセスが同じ NUMA ノード内で実行されるようにすることができます。

ソフト NUMA と CPU アフィニティを構成して R ワークロードをサポートするための全体的なプロセスは次のとおりです。

1. ソフト NUMA を有効にする (使用可能な場合)
2. プロセッサのアフィニティを定義する
3. [Resource Governor](../r/resource-governance-for-r-services.md)を使用して外部プロセス用のリソースプールを作成する
4. [ワークロードグループ](../../relational-databases/resource-governor/resource-governor-workload-group.md)を特定のアフィニティグループに割り当てる

サンプルコードを含む詳細については、次のチュートリアルを参照してください。[SQL の最適化に関するヒントとテクニック (Ke)](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services)

**その他のリソース:**

+ [SQL Server のソフト NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)
    
    ソフト NUMA ノードを Cpu にマップする方法

## <a name="task-specific-optimizations"></a>タスク固有の最適化

このセクションでは、特定の機械学習ワークロードを最適化するために、これらのケーススタディとその他のテストで採用されている方法の概要を示します。 一般的なワークロードには、モデルトレーニング、特徴抽出、特徴エンジニアリング、およびスコアリングのためのさまざまなシナリオ (単一行、小さいバッチ、大きなバッチなど) が含まれます。

### <a name="feature-engineering"></a>機能エンジニアリング

R の1つの問題点は、通常、1つの CPU で処理されることです。 これは、多くのタスク (特に特徴エンジニアリング) におけるパフォーマンスの大きなボトルネックです。 再開照合ソリューションでは、特徴エンジニアリングタスクだけが、元の100機能と組み合わせて使用する必要があったクロス積機能を2500作成しました。 すべてが1つの CPU で実行された場合、このタスクにはかなりの時間がかかります。

特徴エンジニアリングのパフォーマンスを向上させるには、複数の方法があります。 R コードを最適化し、モデリングプロセス内で機能の抽出を維持するか、特徴エンジニアリングプロセスを SQL に移行することができます。

- R を使用します。関数を定義し、トレーニング中に[rxTransform](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxtransform)に引数として渡します。 モデルで並列処理がサポートされている場合、特徴エンジニアリングタスクは複数の Cpu を使用して処理できます。 このアプローチを使用すると、データサイエンスチームはスコアリング時間の観点から 16% のパフォーマンス向上を観察しました。 ただし、この方法では、並列処理をサポートするモデルと、並列プランを使用して実行できるクエリが必要です。

- SQL の計算コンテキストで R を使用します。 分離されたリソースが個別のバッチの実行に使用できるマルチプロセッサ環境では、各バッチに使用される SQL クエリを分離し、テーブルからデータを抽出し、同じワークロードグループにデータを制限することで、効率を高めることができます。 バッチを分離するために使用されるメソッドには、パーティション分割や、PowerShell を使用した個別のクエリの並列実行が含まれます。

- アドホック並列実行:SQL Server の計算コンテキストでは、可能であれば、SQL データベースエンジンを使用して並列実行を適用できます。また、そのオプションがより効率的であることがわかった場合にも使用できます。

- T-sql を別の特性付けプロセスで使用します。 一般に、SQL を使用して機能データを事前に計算する方が高速です。

### <a name="prediction-scoring-in-parallel"></a>並列での予測 (スコアリング)

SQL Server の利点の1つは、大量の行を並行して処理できることです。 この利点は、スコア付けとしてマークされています。 一般に、モデルはスコアリングのためにすべてのデータにアクセスする必要がないため、入力データをパーティション分割して、各ワークロードグループが1つのタスクを処理するようにすることができます。

また、入力データを1つのクエリとして送信し、SQL Server クエリを分析することもできます。 入力データに対して並列クエリプランを作成できる場合は、ノードに割り当てられたデータが自動的にパーティション分割され、必要な結合と集計も並列で実行されます。

スコアリングに使用するストアドプロシージャを定義する方法の詳細については、 [GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips/SQLR)のサンプルプロジェクトを参照して、"step5_score_for_matching" というファイルを探してください。 このサンプルスクリプトでは、クエリの開始時刻と終了時刻を追跡し、SQL コンソールに時間を書き込んで、パフォーマンスを評価することもできます。

### <a name="concurrent-scoring-using-resource-groups"></a>リソースグループを使用した同時スコアリング

スコア付けの問題をスケールアップするには、数百万の項目が複数のバッチに分割されるようにするためのマップ削減アプローチを採用することをお勧めします。 次に、複数のスコアリングジョブが同時に実行されます。 このフレームワークでは、バッチは異なる CPU セットで処理され、結果が収集されてデータベースに書き戻されます。

これは、再開照合シナリオで使用されるアプローチです。ただし、この方法を実装するには、SQL Server のリソースガバナンスが不可欠です。 外部スクリプトジョブのワークロードグループを設定することにより、R スコアリングジョブを異なるプロセッサグループにルーティングして、より高速なスループットを実現することができます。

リソースガバナンスは、ワークロードの競合を最小限にするために、サーバー (CPU およびメモリ) で使用可能なリソースを割り当てることもできます。 さまざまな種類の R ジョブを区別するように分類子関数を設定できます。たとえば、アプリケーションから呼び出されたスコア付けが常に優先され、再トレーニングジョブの優先度が低いと判断する場合などです。 このリソースの分離によって、実行時間が短縮され、より予測可能なパフォーマンスが提供される可能性があります。

### <a name="concurrent-scoring-using-powershell"></a>PowerShell を使用した同時スコアリング

データを自分でパーティション分割する場合は、PowerShell スクリプトを使用して、複数の同時スコアリングタスクを実行できます。 これを行うには、SqlCmd コマンドレットを使用して、スコアリングタスクを並行して開始します。

再開照合シナリオでは、同時実行は次のように設計されています。

- 20個のプロセッサは、それぞれ5つの Cpu の4つのグループに分けられています。 Cpu の各グループは、同じ NUMA ノードに配置されます。

- 同時実行バッチの最大数が8に設定されました。

- 各ワークロードグループは、2つのスコアリングタスクを処理する必要があります。 1つのタスクがデータの読み取りを完了し、スコア付けを開始するとすぐに、他のタスクはデータベースからのデータの読み取りを開始できます。

このシナリオの PowerShell スクリプトを表示するには、 [Github プロジェクト](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips)で「実験. ps1」というファイルを開きます。

### <a name="storing-models-for-prediction"></a>予測用のモデルの格納

トレーニングと評価が完了し、最適なモデルを選択した場合は、モデルを予測に使用できるようにデータベースに保存することをお勧めします。 SQL Server machine learning では、R とデータベース間を移動するときに、特別なシリアル化アルゴリズムを使用してモデルを格納および読み込むため、事前に計算されたモデルをデータベースから予測用に読み込むことは効率的です。

> [!TIP]
> SQL Server 2017 では、サーバーに R がインストールされていない場合でも、PREDICT 関数を使用してスコアリングを実行できます。 RevoScaleR パッケージからは、制限されたモデルの種類がサポートされています。

ただし、使用するアルゴリズムによっては、一部のモデルが非常に大きくなる場合があります (特に、大規模なデータセットに対してトレーニングを行う場合)。 たとえば、 **lm**や**glm**などのアルゴリズムでは、ルールと共に多数の概要データが生成されます。 Varbinary 列に格納できるモデルのサイズには制限があるため、実稼働環境でモデルをデータベースに格納する前に、モデルから不要な成果物を除外することをお勧めします。

## <a name="articles-in-this-series"></a>このシリーズの記事

[R のパフォーマンスチューニング-概要](../r/sql-server-r-services-performance-tuning.md)

[R SQL Server 構成のパフォーマンスチューニング](../r/sql-server-configuration-r-services.md)

[R のパフォーマンスチューニング-R コードとデータの最適化](../r/r-and-data-optimization-r-services.md)

[パフォーマンスチューニング-ケーススタディの結果](../r/performance-case-study-r-services.md)
