---
title: XQuery と静的な型指定 |Microsoft Docs
description: XQuery での静的な型の推定と静的な型チェックについて説明します。
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
author: rothja
ms.author: jroth
ms.openlocfilehash: 6dcaa7bbbd5674c6db3b6d8ec5185cc31e890707
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/10/2021
ms.locfileid: "100352314"
---
# <a name="xquery-and-static-typing"></a>XQuery と静的な型指定
[!INCLUDE [SQL Server Azure SQL Database ](../includes/applies-to-version/sqlserver.md)]

  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] の XQuery は静的型指定の言語です。 つまり、特定の関数または演算子で受け入れられない型またはカーディナリティを持つ値が式から返された場合、クエリのコンパイル中に型エラーが発生します。 また、静的な型チェックでは、型指定された XML ドキュメントのパス式の入力ミスが間違いであるかどうかを検出することもできます。 XQuery コンパイラは、アトミック化などの暗黙的な操作を加える正規化を適用してから、静的な型の推定および確認を行います。  
  
## <a name="static-type-inference"></a>静的な型の推定  
 静的な型の推定では、式の戻り型が判定されます。 この判定は、入力パラメーターの静的な型および演算の静的なセマンティクスを取得し、結果の静的な型を推定することで行われます。 たとえば、式 1 + 2.3 の静的な型は、次のように決定されます。  
  
-   1の静的な型は **xs: integer** で、2.3 の静的な型は **xs: decimal** です。 動的なセマンティクスに基づいて、操作の静的なセマンティクスによって **+** 整数が decimal に変換され、decimal が返されます。 その場合、推定される静的な型は **xs: decimal** になります。  
  
 型指定されていない XML インスタンスの場合、データが型指定されていないことを示す特殊な型があります。 その情報は、静的な型チェックのときに暗黙的に型をキャストするために使用されます。  
  
 型指定されたデータの場合、XML データ型インスタンスを制約する XML スキーマ コレクションから入力の型が推定されます。 たとえば、スキーマで **xs: integer** 型の要素のみが許可されている場合、その要素を使用するパス式の結果は、 **xs: integer** 型の0個以上の要素になります。 現在は、などの式を使用して表されてい `element(age,xs:integer)*` ます。アスタリスク () は、 \* 結果の型のカーディナリティを示します。 この例では、式の結果が "age" という名前の0個以上の要素になり、 **xs: integer** 型になります。 その他の基数は1つだけであり、型名だけを使用して表され、0または1、疑問符 (**?**)、1以上、プラス記号 () を使用して表現され **+** ます。  
  
 場合によっては、静的な型の推論によって、式が常に空のシーケンスを返すことが推論されることがあります。 たとえば、型指定された XML データ型のパス式で、要素 (たとえば、) 内の要素を検索する場合、そのスキーマでは、 \<name> \<customer> 内でを使用できません \<name> \<customer> 。静的な型の推論では、結果が空であると推論されます。 これは、不適切なクエリを検出するために使用され、式が () または **データ (())** でない限り、静的なエラーとして報告されます。  
  
 詳細な推論規則は、XQuery 仕様の正式なセマンティクスとして提供されます。 マイクロソフトでは、型指定された XML データ型のインスタンスに対応するためにこの規則を少しだけ変更しました。 標準からの最も重要な変更点は、暗黙的なドキュメント ノードで XML データ型のインスタンスの型を認識することです。 その結果、/age という形式のパス式は、その情報に基づいて厳密に型指定されます。  
  
 [SQL Server Profiler テンプレートと権限](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md)を使用して、クエリのコンパイルの一部として返される静的な型を確認できます。 これらを確認するには、トレースに TSQL イベント カテゴリの XQuery Static Type イベントが含まれている必要があります。  
  
## <a name="static-type-checking"></a>静的な型チェック  
 静的な型チェックにより、実行時の実行では、操作に適した型の値のみが取得されます。 実行時には必ずしも型がチェックされるとは限りませんが、コンパイルの初期段階で潜在的なエラーを検出できます。 これにより、パフォーマンスが向上します。 ただし、静的な型指定を使用する場合、クエリの記述には通常以上の配慮が必要になります。  
  
 次に、使用できる適切な型を示します。  
  
-   関数または操作によって明示的に許可された型。  
  
-   明示的に許可されている型のサブタイプ。  
  
 サブタイプは、XML スキーマの制約または拡張による派生を使用するためのサブタイプ指定規則に基づいて定義されます。 たとえば、型が S であるすべての値が型 T のインスタンスでもある場合、型 S は型 T のサブタイプです。  
  
 また、すべての整数値は、XML スキーマ型の階層に基づいて、10進値でもあります。 一方、decimal 型のすべての値が integer 型の値であるとは限りません。 したがって、整数は decimal のサブタイプですが、その逆はできません。 たとえば、演算では、 **+** **xs: integer**、 **xs: decimal**、 **xs: float**、 **xs: double** の数値型など、特定の型の値のみを使用できます。 **Xs: string** などの他の型の値が渡された場合、この操作では型エラーが発生します。 これは、厳密な型指定と呼ばれます。 型指定されていない XML を示すために使用されるアトミック型など、他の型の値は、操作で受け入れられる型の値に暗黙的に変換できます。 これは、弱い型指定と呼ばれます。  
  
 暗黙的な変換の後での静的な型チェックを必須にした場合、カーディナリティが正しく、許可された型の値のみが演算に渡されます。 "String" + 1 の場合、"string" の静的な型は **xs: string** であることが認識されます。 これは操作で許可されている型ではないため **+** 、型エラーが発生します。  
  
 任意の式 E1 の結果に任意の式 E2 を加算する (E1 + E2) 場合、静的な型の推定によって E1 および E2 の静的な型が判定されたうえで、それらの型が演算に許可されている型であるかどうかのチェックが行われます。 たとえば、E1 の静的な型が **xs: string** または **xs: integer** のいずれかである場合、実行時に値が整数であっても、静的な型チェックによって型エラーが発生します。 E1 の静的な型が **xs: integer&#42;** の場合も同様です。 この操作では **+** 1 つの整数値のみが受け入れられ、E1 は0または1を超える値を返す可能性があるため、静的な型チェックではエラーが発生します。  
  
 前述のように、型の推定では、渡されるデータの型に関してユーザーが知っているよりも広範な型が推論されることがよくあります。 そのような場合は、ユーザーがクエリを書き換える必要があります。 一般的なケースとしては、次のようなものがあります。  
  
-   スーパータイプまたは型の共用体など、汎化された型が推定される。 型がアトミック型の場合は、キャスト式またはコンストラクター関数を使用して、実際の静的な型を示す必要があります。 たとえば、式 E1 の推定型が **xs: string** または **xs: integer** のいずれかであり、加算に **xs: integer** が必要な場合は、ではなくを記述する必要があり `xs:integer(E1) + E2` `E1+E2` ます。 この式は、 **xs: integer** にキャストできない文字列値が検出された場合に、実行時に失敗する可能性があります。 ただし、この式は静的な型チェックには合格します。 この式は空のシーケンスにマップされます。  
  
-   データの実際の内容を上回るカーディナリティが推定される。 **Xml** データ型には複数の最上位要素を含めることができ、xml スキーマコレクションではこのような制約ができないため、この処理が頻繁に発生します。 静的な型を限定し、渡される値の数を 1 以下にするためには、位置関係の述語 `[1]` を使用してください。 たとえば、トップレベルの要素の下にある要素の属性の値に1を追加するには、を `c` `b` 指定する必要があり `write (/a/b/@c)[1]+1` ます。 また、DOCUMENT キーワードを XML スキーマコレクションと共に使用することもできます。  
  
-   一部の操作では、推論時に型情報が失われます。 たとえば、ノードの型を特定できない場合は、 **anyType** になります。 これは、他の型に暗黙的にキャストされることはありません。 これらの変換は、主に親軸を使用したナビゲーション中に発生します。 式で静的な型のエラーが発生する場合、そのような演算の使用は避け、クエリを書き換えてください。  
  
## <a name="type-checking-of-union-types"></a>Union 型の型チェック  
 共用体型では、型チェックによって慎重に処理する必要があります。 次の例では、2つの問題を示しています。  
  
### <a name="example-function-over-union-type"></a>例: Union 型に対する関数  
 Union 型の <> の要素定義を考えてみましょう `r` 。  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 XQuery のコンテキストでは、"average" 関数は `fn:avg (//r)` 静的エラーを返します。これは、xquery コンパイラが、fn: avg () の引数に含まれる <> 要素に対して異なる型 (**xs: int**、 **xs: float** 、または **xs: double**) の値を追加できないため `r` です。  これを解決するには、関数の呼び出し部分を「`fn:avg(for $r in //r return $r cast as xs:double ?)`」と書き換えます。  
  
### <a name="example-operator-over-union-type"></a>例: Union 型に対する演算子  
 加算演算 (' + ') には、オペランドの正確な型が必要です。 その結果、式は、 `(//r)[1] + 1` 前に説明した要素 <> の型定義を持つ静的エラーを返し `r` ます。 解決策の 1 つは、「`(//r)[1] cast as xs:int? +1`」("?" は 0 回または 1 回の出現を示す) に書き換える方法です。 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、すべてのキャストは実行時エラーの結果として空のシーケンスになる可能性があるので、"cast as" に "?" を付ける必要があります。  
  
## <a name="see-also"></a>参照  
 [XQuery 言語リファレンス &#40;SQL Server&#41;](../xquery/xquery-language-reference-sql-server.md)  
  
  
